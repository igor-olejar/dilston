{
  "name": "hapi",
  "description": "HTTP API Server framework",
  "homepage": "http://hapijs.com",
  "version": "0.8.4",
  "author": {
    "name": "Eran Hammer",
    "email": "eran@hueniverse.com",
    "url": "http://hueniverse.com"
  },
  "contributors": [
    {
      "name": "Van Nguyen",
      "email": "the.gol.effect@gmail.com"
    },
    {
      "name": "Wyatt Preul",
      "email": "wpreul@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/walmartlabs/hapi"
  },
  "main": "index",
  "keywords": [
    "framework",
    "http",
    "authentication",
    "api",
    "router"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "hoek": "0.0.x",
    "joi": "0.0.x",
    "async": "0.1.x",
    "mac": "0.x.x",
    "request": "2.11.x",
    "redis": "0.8.x",
    "ws": "0.4.x",
    "shot": "0.0.x",
    "handlebars": "1.0.x",
    "mongodb": "1.1.x",
    "multipart-parser": "0.x.x"
  },
  "devDependencies": {
    "mocha": "1.x.x",
    "should": "1.x.x",
    "sinon": "1.3.4",
    "chai": "1.2.x"
  },
  "scripts": {
    "test": "make test && make unit"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/walmartlabs/hapi/raw/master/LICENSE"
    }
  ],
  "readme": "![hapi Logo](https://raw.github.com/walmartlabs/hapi/master/images/hapi.png)\n\nA rich framework for building restful API services. **hapi** is a configuration-centric framework in which\nauthentication requirements, input validation, data caching and pre-fetching, developer documentation,\nand other essential facilities are provided out-of-the-box and enabled using simple JSON configuration\nobjects. **hapi** enables developers to focus on writing reusable business logic instead of spending time\nwith everything else.\n\nMailing list: https://groups.google.com/group/hapijs\n\nCurrent version: **0.8.4**\n\n[![Build Status](https://secure.travis-ci.org/walmartlabs/hapi.png)](http://travis-ci.org/walmartlabs/hapi)\n\n# Table of Content\n\n- [**Usage**](#usage)\n\t- [**Basic Usage**](#basic-usage)\n<p></p>\n    - [**Server Construction**](#server-construction)\n<p></p>\n\t- [**Server Configuration**](#server-configuration)\n\t\t- [TLS](#tls)\n\t\t- [Router](#router)\n\t\t- [Payload](#payload)\n\t\t- [Extensions](#extensions)\n\t\t\t- [Unknown Route](#unknown-route)\n\t\t- [Errors](#errors)\n\t\t- [Monitor](#monitor)\n\t\t- [Authentication](#authentication)\n\t\t- [Cache](#cache)\n\t\t- [Debug](#debug)\n\t\t- [Documentation] (#documentation)\n\t\t- [CORS](#cors)\n\t\t- [Batch](#batch)\n<p></p>\n    - [**Server Events**](#server-events)\n<p></p>\n\t- [**Route Configuration**](#route-configuration)\n\t\t- [Configuration options](#configuration-options)\n\t\t- [Override Route Defaults](#override-route-defaults)\n\t\t- [Path Processing](#path-processing)\n\t\t\t- [Parameters](#parameters)\n\t\t- [Route Handler](#route-handler)\n\t\t\t- [Request Logging](#request-logging)\n\t\t- [Query Validation](#query-validation)\n\t\t- [Payload Validation](#payload-validation)\n\t\t- [Response Validation](#response-validation)\n        - [Caching](#caching)\n        - [Proxy](#proxy)\n        - [Route Prerequisites](#route-prerequisites)\n<p></p>\n\t- [**Data Validation**](#data-validation)\n<p></p>\n\t- [**Response Errors**](#response-errors)\n<p></p>\n    - [**General Events Logging**](#general-events-logging)\n<p></p>\n\t- [**Request Tails**](#request-tails)\n<p></p>\n\t- [**Request Injection**](#request-injection)\n<p></p>\n\t- [**Server Helpers**](#server-helpers)\n  \n# Usage\n\n## Basic Usage\n\nThe following is a simple \"hello world\" service with a single API endpoint:\n\n```javascript\nvar Hapi = require('hapi');\n\n// Create a server with a host and port\nvar server = new Hapi.Server('localhost', 8000);\n\n// Define the route\nvar hello = {\n    handler: function (request) {\n    \n        request.reply({ greeting: 'hello world' });\n    }\n};\n\n// Add the route\nserver.addRoute({\n    method: 'GET',\n    path: '/hello',\n    config: hello\n});\n\n// Start the server\nserver.start();\n```\n\nNow navigate to http://localhost:8000/hello and you should receive 'hello world'.\n\n## Server Construction\n\nThe **hapi** Server object is the core of the framework and is constructed by instantiating a new Server object with the following optional parameters:\n- _'host'_ - optional host name. Defaults to 'localhost'.\n- _'port'_ - optional port. Defaults to '80' (or '443' for TLS).\n- _'options'_ - optional configuration as described in [Server Configuration](#server-configuration).\n\n```javascrip\nvar Hapi = require('hapi');\n\n// Create a server on localhost port 80\nvar server = new Hapi.Server();\n```\n\n## Server Configuration\n\n**hapi** provides a rich set of configuration options for each server instance:\n\n- [`tls`](#tls)\n- [`router`](#router)\n- [`payload`](#payload)\n- [`ext`](#extensions)\n- [`errors`](#Errors)\n- [`monitor`](#monitor)\n- [`authentication`](#authentication)\n- [`cache`](#cache)\n- [`debug`](#debug)\n- [`cors`](#cors)\n\n### TLS\n\n**hapi** creates an HTTP server by default. To create an HTTPS server, include the `tls` object in the server configuration.\nThe `tls` object is passed unchanged to the node.js HTTPS server and described in the\n[node.js HTTPS documentation](http://nodejs.org/api/https.html#https_https_createserver_options_requestlistener).\n\n```javascript\nvar Hapi = require('hapi');\n\nvar options = {\n    tls: {\n        key: 'your_key',\n        cert: 'your_cert'\n    }\n};\n\nvar server = new Hapi.Server(options);\n```\n\n### Router\n\nThe `router` option controls how incoming request URIs are matched against the routing table. The router only uses the first match found. Router options:\n- `isTrailingSlashSensitive` - determines whether the paths '/example' and '/example/' are considered different resources. Defaults to _false_.\n- `isCaseSensitive` - determines whether the paths '/example' and '/EXAMPLE' are considered different resources. Defaults to _true_.\n\n### Payload\n\nThe `payload` option controls how incoming payloads (request body) are processed. Payload options:\n- `maxBytes` - limits the size of incoming payloads to the specified bytes count. Allowing very large payloads may cause the server to run out of memory. Defaults to _1MB_.\n\n### Extensions\n\n**hapi** does not support middleware extensibility as is commonly found in other web frameworks. Instead, **hapi** provides extension hooks for\nany application-specific functionality. Each extension point accepts a single function or an array of functions to be execute at a specified stage\nduring request processing. The required extension function signature is _function (request, next)_ where:\n- _'request'_ is the **hapi** request object, and\n- _'next'_ is the callback function the method **must** call upon completion to return control over to the router.\n\nThe extension points are:\n- `onRequest` - called upon new requests before any router processing. The _'request'_ object passed to the `onRequest` functions is decorated with the _'setUrl(url)'_ and _'setMethod(verb)' methods. Calls to these methods will impact how the request is router and can be used for rewrite rules.\n- `onPreHandler` - called after request passes validation and body parsing, before the request handler.\n- `onPostHandler` - called after the request handler, before sending the response.\n- `onPostRoute` - called after the response was sent.\n- `onUnknownRoute` - if defined, overrides the default unknown resource (404) error response. The method must send the response manually via _request.raw.res_. Cannot be an array.\n\nFor example:\n```javascript\nvar Hapi = require('hapi');\n\nvar options = {\n    ext: {\n        onRequest: onRequest\n    }\n};\n\n// Create server\nvar http = new Hapi.Server('localhost', 8000, options);\n\n// Set routes\nhttp.addRoute({ method: 'GET', path: '/test', handler: get });\n\n// Start server\nhttp.start();\n\n// Resource handler\nfunction get(request) {\n\n    request.reply({ status: 'ok' });\n}\n\n// Path rewrite\nfunction onRequest(request, next) {\n\n    // Change all requests to '/test'\n    request.setUrl('/test');\n    next();\n}\n```\n\n#### Unknown Route\n\n**hapi** provides a default handler for unknown routes (HTTP 404). If the application needs to override the default handler, it can use the\n`ext.onUnknownRoute` server option. The extension function signature is _function (request)_ where:\n- _'request'_ is the **hapi** request object.\nWhen the extension handler is called, the _'request'_ object is decorated as described in [Route Handler](#route-handler) with the following additional method:\n- _'reply.close()'_ - returns control over to the server after the application has taken care of responding to the request via the _request.raw.res_ object directly.\nThe method **must** return control over to the route using the _reply_ interface described in [Route Handler](#route-handler) or the _'reply.close()'_ method but not both.\n\nFor example, using the _'reply.close()'_ method:\n```javascript\nvar Hapi = require('hapi');\n\nvar options = {\n    ext: {\n        onUnknownRoute: onUnknownRoute\n    }\n};\n\n// Create server\nvar http = new Hapi.Server('localhost', 8000, options);\n\n// Start server\nhttp.start();\n\n// 404 handler\nfunction onUnknownRoute(request) {\n\n    request.raw.res.writeHead(404);\n    request.raw.res.end();\n    request.reply.close();\n}\n```\n\nOr using the _'reply(result)'_ method:\n```javascript\nfunction onUnknownRoute(request) {\n\n    request.reply({ roads: 'ocean' });\n}\n```\n\n### Errors\n\nIf a different error format than the default JSON response is required, the server `errors.format` option can be assigned a function to generate a\ndifferent error response. The function signature is _'function (result, callback)'_ where:\n- _'result'_ - is the **hapi** error object returned by the route handler, and\n- _'callback'_ - is a callback function called with the formatted response. The callback function signature is _'function (code, payload, contentType)'_.\n\nFor example:\n```javascript\nvar options = {\n    errors: {\n        format: function (result, callback) {\n        \n            callback(500, 'Oops: ' + result.message, 'text/html');\n        }\n    }\n};\n```\n\n### Monitor\n\n**hapi** comes with a built-in process monitor for three types of events:\n- System and process performance (ops) - CPU, memory, disk, and other metrics.\n- Requests logging (request) - framework and application generated logs generated during the lifecycle of each incoming request.\n- General events (log) - logging information not bound to a specific request such as system errors, background processing, configuration errors, etc. Described in [General Events Logging](#general-events-logging).\n\nThe monitor is _off_ by default and can be turned on using the `monitor` server option. To use the default settings, simply set the value to _true_.\nApplications with multiple server instances, each with its own monitor should only include one _log_ subscription per destination as general events (log)\nare a process-wide facility and will result in duplicated log events. To override some or all of the defaults, set `monitor` to an object with the following\noptional settings:\n- `broadcastInterval` - the interval in milliseconds to send collected events to subscribers. _0_ means send immediately. Defaults to _0_.\n- `opsInterval` - the interval in milliseconds to sample system and process performance metrics. Minimum is _100ms_. Defaults to _15 seconds_.\n- `extendedRequests` - determines if the full request log is sent or only the event summary. Defaults to _false_.\n- `requestsEvent` - the event type used to capture completed requests. Defaults to 'tail'. Options are:\n  - 'response' - the response was sent but request tails may still be pending.\n  - 'tail' - the response was sent and all request tails completed.\n- `subscribers` - an object where each key is a destination and each value an array subscriptions. Subscriptions available are _ops_, _request_, and _log_. The destination can be a URI or _console_. Defaults to a console subscription to all three.\n\nFor example:\n```javascript\nvar options = {\n    monitor: {\n        subscribers: {\n            console: ['ops', 'request', 'log'],\n            'http://localhost/logs': ['log']\n        }\n    }\n};\n```\n\n### Authentication\n\nThe authentication interface is disabled by default and is still experimental.\n\n### Cache\n\n**hapi** provides a built-in caching facility for storing and reusing request responses and helpers utilities. The provided implementations include Redis and MongoDB support\n(each must be manually installed and configured). The cache functionality is _off_ by default. To enable caching, the `cache` option must be set to\nan object with the following options:\n- `engine` - the cache server implementation. Options are _redis_, _mongodb_, and _memory_.\n- `host` - the cache server hostname.\n- `port` - the cache server port.\n- `partition` - the partition name used to isolate the cached results across different servers. Defaults to 'hapi-cache'.\n- `username`, `password`, `poolSize` - MongoDB-specific options.\n\nFor convenience, pre-configured options are provided for Redis, MongoDB, and an experimental memory store. To use them, simply set the server's `cache` option to:\n* _'redis'_ - Connects to _127.0.0.1:6379_ using partition name 'hapi-cache'.\n* _'mongodb'_ - Connects to _127.0.0.1:27017_ using partition name 'hapi-cache', no authentication, and pool size 5.\n* _'memory'_ - This is an experimental engine and should be avoided in production environments.  The memory engine will run within the node process and supports the following option:\n    - `maxByteSize` - Sets an upper limit on the number of bytes that can be consumed by the total of everything cached in the memory engine.  Once this limit is reached no more items will be added to the cache.\n\nFor example:\n```javascript\nvar options = {\n    cache: 'redis'\n};\n```\n\nEnabling the server cache only creates the cache interface but does not enable caching for any individual routes or helpers, which must be enabled\nand configured in the route or helper configuration.\n\n### Debug\n\nTo assist in debugging server events related to specific incoming requests, **hapi** includes an optional debug console which is turned _off_ by default.\nThe debug console is a simple web page in which developers can subscribe to a debug id, and then include that debug id as an extra query parameter in each\nrequest. The server will use WebSocket to stream the subscribed request logs to the web page in real-time. In application using multiple server instances,\nonly one can enable the debug interface using the default port. To enable the debug console set the `debug` option to _true_ or to an object with custom\nconfiguration:\n- `websocketPort` - the port used by the WebSocket connection. Defaults to _3000_.\n- `debugEndpoint` - the debug console request path added to the server routes. Defaults to _'/debug/console'_.\n- `queryKey` - the name or the request query parameter used to mark requests being debugged. Defaults to _debug_.\n\n### Documentation\n\n**This is an experimental feature and is likely to change!**\n\nIn order to make it easy to generate documentation for the routes you add to **hapi**, a documentation generator is provided. By default the documentation\ngenerator is turned _off_. To enable the docs endpoint set the `docs` option to _true_ or to an object with custom configuration:\n- `docsEndpoint` - the path where the documentation will be served from. Default is '/docs'.\n- `indexTemplatePath` - the file path where the index template file is located.  Default is 'lib/templates/index.html'.\n- `indexTemplate` - the raw source of a index template to use.  If `indexTemplate` is provided then it will be used over the file located at `indexTemplatePath`.\n- `routeTemplatePath` - the file path where the routes template file is located.  Default is 'lib/templates/route.html'.\n- `routeTemplate` - the raw source of a route template to use.  If `routeTemplate` is provided then it will be used over the file located at `routeTemplatePath`.\n- `templateParams` - an optional object of any extra information you want to pass into your template, this will be located in the templateParams object in the template data object.\n\nBy default there is an index page that lists all of the available routes configured in **hapi** that is located at the `docsEndpoint`.  From this page users are able to navigate to individual routes to read the related documentation.\n\n### CORS\n\nThe [Cross-Origin Resource Sharing](http://www.w3.org/TR/cors/) protocol allows browsers to make cross-origin API calls. This is required\nby web application running inside a browser which are loaded from a different domain than the API server. **hapi** provides a general purpose\nCORS implementation that sets very liberal restrictions on cross-origin access by default (on by default). CORS options:\n- `origin` - overrides the array of allowed origin servers ('Access-Control-Allow-Origin'). Defaults to any origin _'*'_.\n- `maxAge` - number of seconds the browser should cache the CORS response ('Access-Control-Max-Age'). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to _one day_.\n- `headers` - overrides the array of allowed headers ('Access-Control-Allow-Headers'). Defaults to _'Authorization, Content-Type, If-None-Match'_.\n- `additionalHeaders` - an array of additional headers to `headers`. Use this to keep the default headers in place.\n- `methods` - overrides the array of allowed methods ('Access-Control-Allow-Methods'). Defaults to _'GET, HEAD, POST, PUT, DELETE, OPTIONS'_.\n- `additionalMethods` - an array of additional methods to `methods`. Use this to keep the default methods in place.\n\n**hapi** will automatically add an _OPTIONS_ handler for every route unless disabled. To disable CORS for the entire server, set the `cors` server option to _false_. To disable CORS support for a single route, set the route _config.cors_ option to _false_.\n\n### Batch\n\nThe batch endpoint makes it easy to combine requests into a single one.  It also supports pipelining so you are able to take the result of one of the endpoints in the batch request and use it in a subsequent endpoint.  The batch endpoint only responds to POST requests.\nBy default the batch endpoint is turned _off_.  To enable the batch endpoint set the `batch` option to _true_ or to an object with the following custom configuration:\n- `batchEndpoint` - the path where batch requests will be served from.  Default is '/batch'.\n\nAs an example to help explain the use of the endpoint, assume that the server has a route at '/currentuser' and '/users/{id}/profile/'.  You can make a POST request to the batch endpoint with the following body:\n`{ \"requests\": [ {\"method\": \"get\", \"path\": \"/currentuser\"}, {\"method\": \"get\", \"path\": \"/users/$0.id/profile\"} ] }` and it will return an array with the current user and their profile.\n\nThe response body to the batch endpoint is an ordered array of the response to each request.  Therefore, if you make a request to the batch endpoint that looks like `{ \"requests\": [ {\"method\": \"get\", \"path\": \"/users/1\"}, {\"method\": \"get\", \"path\": \"/users/2\"} ] }` the response might look like:\n`[{\"userId\": \"1\", \"username\": \"bob\"}, {\"userId\": \"2\", \"username\": \"billy\" }]` where the first item in the response array is the result of the request from the first item in the request array.\n\nIf an error occurs as a result of one the requests to an endpoint it will be included in the response in the same location in the array as the request causing the issue.  The error object will include an error property that you can interrogate.  At this time the response is a 200 even when a request in the batch returns a different code.\n\n*** At this time batch only supports requests to routes that use the GET method.\n\n## Server Events\n\nThe server object emits the following events:\n- _'response'_ - emitted after a response is sent back. Includes the request object as value.\n- _'tail'_ - emitted when a request finished processing, including any registered tails as described in [Request Tails](#request-tails).\n\n## Route Configuration\n\n**hapi** was designed to move as much logic as possible from the route handler to the route configuration. The goal is to provide a simple\nmechanism for defining routes without having to write code. This approach also enables producing dynamic route documentation without having\nto write additional text as the configuration itself serves as a living documentation.\n\n### Configuration options \n\n* `path` - the absolute path or regular expression to match against incoming requests. Path comparison is configured using the server [`router`](#router) option. String paths can include named identifiers prefixed with _':'_ as described in [Path Parameters](#path-processing).\n* `method` - the HTTP method. Typically one of _'GET, POST, PUT, DELETE, OPTIONS'_. Any HTTP method is allowed, except for _'HEAD'_. **hapi** does not provide a way to add a route to all methods.\n* `handler` - the business logic function called after authentication and validation to generate the response. The function signature is _function (request)_ where _'request'_ is the **hapi** request object. See [Route Handler](#route-hander) for more information.\n* `config` - route configuration grouped into a sub-object to allow splitting the routing table from the implementation details of each route. Options include:\n  * `description` - route description.\n  * `notes` - route notes (string or array of strings).\n  * `tags` - route tags (array of strings).\n  * `handler` - an alternative location for the route handler function. Same as the `handler` option in the parent level. Can only include one handler per route.\n  * `query` - validation rules for incoming requests' query component (the key-value part of the URI between _?_ and _#_). Defaults to no query parameters allowed. See [Query Validation](#query-validation) for more information.\n  * `schema` - validation rules for incoming requests' payload (request body). Defaults to no validation (any payload allowed). Set to an empty object _'{}'_ to forbid payloads. See [Payload Validation](#payload-validation) for more information.\n  * `response` - validation rules for outgoing responses' payload (response body). Defaults to no validation (any payload allowed). Set to an empty object _'{}'_ to forbid payloads. See [Response Validation](#response-validation) for more information.\n  * `payload` - determines how the request payload is processed. Defaults to _'parse'_ if `schema` is present or `method` is _'POST'_ or _'PUT'_, otherwise _'stream'_. Payload processing is configured using the server [`payload`](#payload) option. Options are:\n    * _'stream'_ - the incoming request stream is left untouched, leaving it up to the handler to process the request via _'request.raw.req'_.\n    * _'raw'_ - the payload is read and stored in _'request.rawBody'_ but not parsed.\n    * _'parse'_ - the payload is read and stored in _'request.rawBody'_ and then parsed (JSON or form-encoded) and stored in _'request.payload'_.\n  * `cache` - if the server `cache` option is enabled and the route method is 'GET', the route can be configured to use the cache as described in [Caching](#caching).\n  * `pre` - an array with pre-handler methods as described in [Route Prerequisites](#route-prerequisites). \n  * `auth` - authentication configuration\n    * `mode` - the authentication mode. Defaults to _'required'_ is the `authentication` server option is set, otherwise _'none'_. Available options include:\n      * _'none'_ - authentication not allowed.\n      * _'required'_ - authentication is required.\n      * _'optional'_ - authentication is optional (validated if present).\n    * `tos` - minimum terms-of-service version required. This is compared to the terms-of-service version accepted by the user. Defaults to _none_.\n    * `scope` - required client scope. Defaults to _none_.\n    * `entity` - the required authenticated entity type. Available options include:\n      * _'any'_ - the authentication can be on behalf of a user or client.\n      * _'user'_ - the authentication must be on behalf of a user.\n      * _'client'_ - the authentication must be on behalf of a client.\n\nThe `config` option was defined for easily spliting the routing table definition from the individual route information. For example:\n```javascript\nvar Hapi = require('hapi');\n\nvar server = new Hapi.Server();\n\n// Option 1 - add handler directly in route definition\n\nvar handler1 = function (request) {\n\n    request.reply('ok');\n}\n\nserver.addRoute({ method: 'GET', path: '/option1', handler: handler1 });\n\n// Option 2 - add handler in seprate config object\n\nvar config2 = {\n    payload: 'raw',\n    // ... additional config options ...\n    handler: function (request) {\n\n        request.reply('ok');\n    }\n};\n\nserver.addRoute({ method: 'GET', path: '/option2', config: config2});\n```\n\n### Override Route Defaults\n\nEach configuration option comes with a built-in default. To change these defaults, use the `setRoutesDefaults()` server method.\n```javascript\nserver.setRoutesDefaults({\n    cors: false\n});\n```\n\n### Path Processing\n\nThe **hapi** router iterates through the routing table on each incoming request and executes the first (and only the first) matching route handler.\nRoute matching is done on the request path only (excluding the query and other components). The route `path` option support three types of paths:\n* Static - the route path is a static string which begin with _'/'_ and will only match incoming requests containing the exact string match (as defined by the server `router` option).\n* Parameterized - same as _static_ with the additional support of named parameters (prefixed with _':'_).\n\n#### Parameters\n\nParameterized paths are processed by matching the named parameters to the content of the incoming request path at that level. For example, the route:\n'/book/{id}/cover' will match: '/book/123/cover' and 'request.params.id' will be set to '123'. Each path level (everything between the opening _'/'_ and\n the closing _'/'_ unless it is the end of the path) can only include one named parameter. The _'?'_ suffix following the parameter name indicates\nan optional parameter (only allowed if the parameter is at the ends of the path). For example: the route: '/book/{id?}' will match: '/book/' (and may\nmatch '/book' based on the server `router` option).\n\n```javascript\nserver.addRoute({\n    path: '/{album}/{song?}',\n    method: 'GET',\n    handler: getAlbum\n});\n\nfunction getAlbum(request) {\n\n    request.reply('You asked for ' +\n                  (request.params.song ? request.params.song + ' from ' : '') +\n                  request.params.album);\n}\n```\n\n### Route Handler\n\nWhen the provided route handler method is called, it receives a _request_ object with the following properties:\n- _'url'_ - the parsed request URI.\n- _'path'_ - the request URI's path component.\n- _'method'_ - the request method as a _lowercase_ string. (Examples: `'get'`, `'post'`).\n- _'query'_ - an object containing the query parameters.\n- _'params'_ - an object containing the path named parameters as described in [Path Parameters](#parameters).\n- _'rawBody'_ - the raw request payload (except for requests with `config.payload` set to _'stream'_).\n- _'payload'_ - an object containing the parsed request payload (for requests with `config.payload` set to _'parse'_).\n- _'session'_ - available for authenticated requests and includes:\n    - _'used'_ - user id.\n    - _'client'_ - client id.\n    - _'tos'_ - terms-of-service version.\n    - _'scope'_ - approved client scopes.\n- _'server'_ - a reference to the server object.\n- _'addTail([name])'_ - adds a request tail as described in [Request Tails](#request-tails).\n- _'raw'_ - an object containing the Node HTTP server 'req' and 'req' objects. **Direct interaction with these raw objects is not recommended.**\n- _'response'_ - contains the route handler's response after the handler is called. **Direct interaction with this raw objects is not recommended.**\n\nThe request object is also decorated with a _'reply'_ property which includes the following methods:\n- _'send([result])'_ - replies to the resource request with result - an object (sent as JSON), a string (sent as HTML), or an error generated using the 'Hapi.error' module described in [Errors](#errors). If no result is provided, an empty response body is sent. Calling _'send([result])'_ returns control over to the router.\n- _'pipe(stream)'_ - pipes the content of the stream into the response. Calling _'pipe([stream])'_ returns control over to the router.\n- _'created(location)`_ - a URI value which sets the HTTP response code to 201 (Created) and adds the HTTP _Location_ header with the provided value (normalized to absolute URI).\n- _'bytes(length)'_ - a pre-calculated Content-Length header value. Only available when using _'pipe(stream)'_.\n- _'type(mimeType)'_ - a pre-determined Content-Type header value. Should only be used to override the built-in defaults.\n- _'ttl(msec)'_ - a milliseconds value which overrides the default route cache expiration rule for this individual response.\n\nIn addition, the _'reply([result])'_ shortcut is provided which is identical to calling _'reply.send([result])'_.\n\nThe handler must call _'reply()'_, _'reply.send()'_, or _'reply.pipe()'_ (and only one, once) to return control over to the router. The helper methods are only available\nwithin the route handler and are disabled as soon as control is returned.\n\n#### Request Logging\n\nIn addition to the [General Events Logging](#general-events-logging) mechanism provided to log non-request-specific events, **hapi** provides\na logging interface for individual requests. By associating log events with the request responsible for them, it is easier to debug and understand\nthe server's behavior. It also enables batching all the request log events and deliver them to the monitor as a single package.\n\nThe request object is also decorated with the following methods.\n- _'log(tags, [data, timestamp])'_ which adds a record to the request log where:\n  - _'tags'_ - a single string or an array of strings (e.g. _['error', 'database', 'read']_) used to identify the logged event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events.\n  - _'data'_ - an optional message string or object with the application data being logged.\n  - _'timestamp'_ - an optional timestamp override (if not present, the server will use current time), expressed in milliseconds since 1970 (_new Date().getTime()_).\n- _'getLog(tags)'_ - Returns an array of events which match the tag(s) specifed.\n  \nFor example:\n```javascript\nvar Hapi = require('hapi');\n\n// Create Hapi servers\nvar http = new Hapi.Server('0.0.0.0', 8080);\n\n// Route handler\nvar testLogs = function (request) {\n\n    request.log('error', new Error('Something failed'));\n    \n    if (request.getLog('error').length === 0) {\n        request.reply('Success!');\n    }\n    else {\n        request.reply('Failure!');\n    }\n};\n\n// Set routes\nhttp.addRoute({ method: 'GET', path: '/', handler: testLogs });\n\n// Start Hapi servers\nhttp.start();\n```\n\nThe 'request.log' method is always available.\n\n### Query Validation\n\nWhen a request URI includes a query component (the key-value part of the URI between _?_ and _#_), the query is parsed into its individual\nkey-value pairs (see [Query String](http://nodejs.org/api/querystring.html#querystring_querystring_parse_str_sep_eq_options)) and stored in\n'request.query'.\n\nThe route `config.query` defines the query validation rules performed before the route handler is invoked. Supported values:\n- _'false'_ or _'null'_ - no query parameters allowed. This is the default.\n- _'true'_ - any query parameters allowed (no validation performed).\n- a validation rules object as described in [Data Validation](#data-validation).\n\n### Payload Validation\n\nThe route `config.schema` defines the payload validation rules performed before the route handler is invoked. Supported values:\n- _'null'_ - any payload allowed (no validation performed). This is the default.\n- _'false'_ or _'{}'_ - no payload allowed.\n- a validation rules object as described in [Data Validation](#data-validation).\n\n### Response Validation\n\nThe route `config.response` defines the payload validation rules performed after the route handler is invoked. Supported values:\n- _'null'_ - any payload allowed (no validation performed). This is the default.\n- _'false'_ or _'{}'_ - no payload allowed.\n- a validation rules object as described in [Data Validation](#data-validation).\n\nResponse validation can only be performed on object responses and will otherwise result in an error.\n\n### Caching\n\n'GET' routes may be configured to use the built-in cache if enabled using the server `cache` option. The route cache config has the following options:\n* `mode` - determines if the route is cached on the server, client, or both. Defaults to _'server+client'_.\n    * `server+client` - Caches the route response on the server and client (default)\n    * `client` - Sends the Cache-Control HTTP header on the response to support client caching\n    * `server` - Caches the route on the server only\n    * `none` - Disable cache for the route on both the client and server\n* `segment` - Optional segment name, used to isolate cached items within the cache partition. Defaults to '#name' for server helpers and the path fingerprint (the route path with parameters represented by a '?' character) for routes. Note that when using the MongoDB cache strategy, some paths will require manual override as their name will conflict with MongoDB collection naming rules.\n* `expiresIn` - relative expiration expressed in the number of milliseconds since the item was saved in the cache. Cannot be used together with `expiresAt`.\n* `expiresAt` - time of day expressed in 24h notation using the 'MM:HH' format, at which point all cache records for the route expire. Cannot be used together with `expiresIn`.\n\nFor example, to configure a route to be cached on the client and to expire after 2 minutes the configuration would look like the following:\n```\n{\n    mode: 'client',\n    expiresIn: 120000\n}\n```\n\nThe server-side cache also supports these advanced options:\n* `staleIn` - number of milliseconds from the time the item was saved in the cache after which it is considered stale. Value must be less than 86400000 milliseconds (one day) if using `expiresAt` or less than the value of `expiresIn`. Used together with `staleTimeout`.\n* `staleTimeout` - if a cached response is stale (but not expired), the route will call the handler to generate a new response and will wait this number of milliseconds before giving up and using the stale response. When the handler finally completes, the cache is updated with the more recent update. Value must be less than `expiresIn` if used (after adjustment for units).\n\n### Proxy\n\nIt is possible with hapi to setup a reverse proxy for routes.  This is especially useful if you plan to stand-up hapi in front of an existing API or you need to augment the functionality of an existing API.  Additionally, this feature is powerful in that it can be combined with caching to cache the responses from external APIs.  The proxy route configuration has the following options:\n* `passThrough` - determines if the headers sent from the clients user-agent will be forwarded on to the external service being proxied to (default: false)\n* `xforward` - determines if the x-forward headers will be set when making a request to the proxied endpoint (default: false)\n* `host` - The host to proxy requests to.  The same path on the client request will be used as the path to the host.\n* `port` - The port to use when making a request to the host.\n* `protocol` - The protocol to use when making a request to the proxied host (http or https)\n* `mapUri` - A function that receives the clients request and a passes the URI to a callback to make the proxied request to.  If host is set mapUri cannot be used, set either host or mapUri.\n* `postResponse` - A function that will be executed before sending the response to the client for requests that can be cached.  Use this for any custom error handling of responses from the proxied endpoint.\n\nFor example, to proxy a request to the homepage to google:\n```javascript\n// Create Hapi servers\nvar http = new Hapi.Server('0.0.0.0', 8080);\n\n// Proxy request to / to google.com\nhttp.addRoute({ method: 'GET', path: '/', config: { proxy: { protocol: 'http', host: 'google.com', port: 80 } } });\n\nhttp.start();\n\n### Prequisites\n\nBefore the handler is called, it is often necessary to perform other actions such as loading required reference data from a database. The `pre` option\nallows defining such pre-handler methods. The methods are called in order, unless a `mode` is specified with value 'parallel' in which case, all the parallel methods\nare executed first, then the rest in order. The `pre` is a mixed array of functions and objects. If a function is included, it is the same as including an\nobject with a single `method` key. The object options are:\n* `method` - the function to call. The function signature is _'function (request, next)'_. _'next([result])'_ must be called when the operation concludes. If the result is an Error, execution of other prerequisites stops and the error is handled in the same way as when an error is returned from the route handler.\n* `assign` - key name to assign the result of the function to within 'request.pre'.\n* `mode` - set the calling order of the function to 'serial' or 'parallel'. Defaults to 'serial'.\n\nFor example:\n```javascript\n// Create Hapi servers\nvar http = new Hapi.Server('0.0.0.0', 8080);\n\nvar fetch1 = function (request, next) {\n\n    next('Hello');\n};\n\nvar fetch2 = function (request, next) {\n\n    next('World');\n};\n\nvar fetch3 = function (request, next) {\n\n    next(request.pre.m1 + ' ' + request.pre.m2);\n};\n\nvar get = function (request) {\n\n    request.reply(request.pre.m3 + '\\n');\n};\n\n// Set routes\nhttp.addRoute({\n    method: 'GET',\n    path: '/',\n    config: {\n        pre: [\n            { method: fetch1, assign: 'm1', mode: 'parallel' },\n            { method: fetch2, assign: 'm2', mode: 'parallel' },\n            { method: fetch3, assign: 'm3' },\n        ],\n        handler: get\n    }\n});\n\n// Start Hapi servers\nhttp.start();\n```\n\n## Data Validation\n\n**hapi** supports a rich set of data types and validation rules which are described in detail in [Validation Configuration](docs/ValidationConfig.md).\nFor example:\n\n```javascript\nvar Hapi = require('hapi');\n\nvar S = Hapi.Types.String;\nvar I = Hapi.Types.Int;\n\nvar rules = {\n  username: S().required().alphanum().min(3).max(30).with('email'),\n  password: S().regex(/[a-zA-Z0-9]{3,30}/).without('token'),\n  token: S(),\n  birthyear: I().min(1850).max(2012),\n  email: S().email(),\n  type: S().valid('admin', 'limited', 'normal')\n};\n```\n\nIn which:\n- 'username' is a required alphanumeric string, 3 to 30 characters long, and must appear together with 'email'.\n- 'password' is an optional string matching a regular expression, and must not appear together with 'token'.\n- 'token' is an optional string.\n- 'birthyear' is an optional integer between 1980 and 2012.\n- 'email' is an optional string with valid email address.\n- 'type' is an optional string which must be set to one of three available values.\n\n## Response Errors\n\nThe 'Hapi.Error' module provides helper methods to generate error responses:\n- _'badRequest([message])'_ - HTTP 400 (Bad Request).\n- _'unauthorized([message])'_ - HTTP 401 (Unauthorized).\n- _'forbidden([message])'_ - HTTP 403 (Not Allowed).\n- _'notFound([message])'_ - HTTP 404 (Not Found).\n- _'internal([message, data])'_ - HTTP 500 (Internal Error). The optional _message_ and _data_ values are not returned to the client but are logged internally.\n\nThe _message_ value is optional and will be returned to the client in the response unless noted otherwise. For example:\n\n```javascript\nfunction onUnknownRoute(request) {\n\n    request.reply(Hapi.Error.unknown('Sorry, nobody home'));\n}\n```\n\nError responses are send as JSON payload with the following keys (unless an [error response override](#errors) is configured):\n- _code_ - the HTTP status code (e.g. 400).\n- _error_ - the HTTP status message (e.g. 'Bad Request').\n- _message_ - the returned message if provided.\n\nThe complete error repsonse including any additional data is added to the request log.\n\n## General Events Logging\n\nMost of the server's events usually relate to a specific incoming request. However, there are sometimes event that do not have a specific request\ncontext. **hapi** provides a logging mechanism for general events using a singleton logger 'Hapi.Log' module. The logger provides the following methods:\n- _'event(tags, [data, timestamp])'_ - generates an event where:\n  - _'tags'_ - a single string or an array of strings (e.g. _['error', 'database', 'read']_) used to identify the event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events.\n  - _'data'_ - an optional message string or object with the application data being logged.\n  - _'timestamp'_ - an optional timestamp override (if not present, the server will use current time), expressed in milliseconds since 1970 (_new Date().getTime()_).\n- _'print(event)'_ - outputs the given _'event'_ to the console.\n\nThe logger is an event emitter. When an event is generated, the logger's _'log'_ event is emitted with the event object as value.\nIf no listeners are registered, the event is printed to the console.\n\nFor example:\n```javascript\nvar Hapi = require('hapi');\n\n// Listen to log events\nHapi.Log.on('log', function (event) {\n\n    // Send to console\n    Hapi.Log.print(event);\n});\n\n// Generate event\nHapi.Log.event(['test','info'], 'Test event');\n\n```\n\n## Request Tails\n\nIt is often desirable to return a response as quickly as possible and perform additional (slower) actions afterwards (or in parallel). These\nactions are called request tails. For example, a request may trigger a database update tail that should not delay letting the client know the\nrequest has been received and will be processed shortly. However, it is still desirable to associate the tails with the request and to know\nwhen every single request related action has completed (in other words, when the request stopped wagging).\n\n**hapi** provides a simple facility for keeping track of pending tails by providing the following request methods:\n- _'addTail([name])'_ - registers a named tail and returns a tail function. The tail function must be retained and used to remove the tail when completed. The method is available on every event or extension hook prior to the 'tail' event.\n- _'removeTail(tail)'_ - removes a tail to notify the server that the associated action has been completed.\n\nAlternatively, the returned tail function can be called directly without using the _removeTail()_ method.\n\nFor example:\n```javascript\nvar Hapi = require('hapi');\n\n// Create Hapi servers\nvar http = new Hapi.Server('0.0.0.0', 8080);\n\n// Route handler\nvar get = function (request) {\n\n    var tail1 = request.addTail('tail1');\n    setTimeout(function () {\n\n        request.removeTail(tail1);              // Using removeTail() interface\n    }, 5000);\n\n    var tail2 = request.addTail('tail2');\n    setTimeout(function () {\n\n        tail2();                                // Using tail function interface\n    }, 2000);\n\n    request.reply('Success!');\n};\n\n// Set routes\nhttp.addRoute({ method: 'GET', path: '/', handler: get });\n\n// Listen to tail events\nhttp.on('tail', function (request) {\n\n    console.log('Wag the dog');\n});\n\n// Start Hapi servers\nhttp.start();\n```\n\n## Request Injection\n\nRequest injection is the process of simulating an HTTP request without making an actual socket request. Injection is useful for testing\nor debugging purposes, but also for invoking routing logic internally without the overhead or limitations of the network stack. For example,\nimplementing a batch mechanism which calls multiple internal routes.\n\n**hapi** uses the [**shot**](https://github.com/hueniverse/shot) module for performing injections. To inject a request, use the server's\n_'inject(options, callback)'_ method in which:\n- _'options'_ - is an object containing the request information. Available options:\n  - `method` - the request HTTP method. Required.\n  - `url` - the request URL (as it would appear in an incoming node request object). Required.\n  - `headers` - any request headers. Optional.\n  - `payload` - a string or Buffer containing the request payload. Optional.\n  - `session` - a session object containing authentication information as described in [Route Handler](#route-handler). The `session` option is used to bypass the default authentication validation and use a pre-authenticated session. Optional.\n- _'callback'_ - a callback function with the signature _'function (res)'_ where 'res' is the injection response object. The response object properties include:\n  - _'headers'_ - an array containing the headers set.\n  - _'statusCode'_ - the HTTP status code.\n  - _'readPayload()'_ - the payload converted to a string.\n  - _'result'_ - if present, the original route handler reply object.\n  - _'raw'_ - the injection request and response objects.\n\n**This is an experimental feature and is likely to change!**\n\nFor example:\n\n```javascript\n// Create Hapi server\nvar http = new Hapi.Server('0.0.0.0', 8080);\n\n// Handler\nvar get = function (request) {\n\n    request.reply('Success!');\n};\n\n// Set routes\nhttp.addRoute({ method: 'GET', path: '/', handler: get });\n\n// Injection options\nvar req = {\n    method: 'get',\n    url: '/'\n};\n\nhttp.inject(req, function (res) {\n\n    console.log(res.result || res.readPayload());\n});\n```\n\n## Server Helpers\n\nServer helpers are functions registered with the server and can be used throughout the application. The advantage of using helpers is\nthat they can be configured to use the built-in cache and shared across multiple request handlers. This provides a useful method for\nspeeding up performance by declaring functions as common utilities with a shared cache.\n\nThe signature of helper functions is _'function (arg1, arg2, ..., arg3, next)'_ where next is a function defined as _'function (result)'_.\n'result' can be any value or an Error (which must be generated using the **hapi** Error module is the helper is used as a prerequisite method).\n\nTo add a helper, use the server's _'addHelper(name, method, options)'_ method where:\n* _'name'_ - is a unique helper name used to call the method (e.g. 'server.helpers.name').\n* _'method'_ - is the helper function.\n* _'options'_ - optional settings where:\n  * `cache` - cache configuration as described in [Caching](#caching). `mode` can use the default or be set to 'server'.\n  * `keyGenerator` - the server will automatically generate a unique key if the function's arguments (with the exception of the last 'next' argument) are all of type string, number, or boolean. However if the function uses other types of arguments, a key generation function must be provided which takes the same arguments as the function and returns a unique string (or null if no key can be generated). Note that when the keyGenerator method is invoked, the arguments list will include the next argument which must not be used in calculation of the key.\n\nFor example:\n```javascript\n// Create Hapi server\nvar server = new Hapi.Server('0.0.0.0', 8080);\n\nvar user = function (id, next) {\n\n    next({ id: id });\n};\n\nvar options = {\n    cache: {\n        expiresIn: 2000,\n        staleIn: 1000,\n        staleTimeout: 100\n    },\n    keyGenerator: function (id) {\n\n        return id;\n    };\n};\n\nserver.addHelper('user', user, options);\n\nserver.helpers.user(4, function (result) {\n\n    console.log(result);\n});\n```\n\nOr used as a prerequisites:\n```javascript\nhttp.addRoute({\n    method: 'GET',\n    path: '/user/{id}',\n    config: {\n        pre: [\n            {\n                assign: 'user',\n                method: function (request, next) {\n\n                    request.server.helpers.user(request.params.id, next);\n                }\n            }\n        ],\n        handler: function (request) {\n\n            request.reply(request.pre.user);\n        }\n    }\n});\n```\n\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/walmartlabs/hapi/issues"
  },
  "_id": "hapi@0.8.4",
  "_from": "hapi@0.8.x"
}
